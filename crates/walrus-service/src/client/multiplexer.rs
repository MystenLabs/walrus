// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

//! A client mulitplexer, that allows to submit requests using multiple clients in the background.

// TODO: refactor the stress client to use the client multiplexer

use std::{future::Future, sync::Arc, time::Duration};

use prometheus::Registry;
use sui_sdk::{
    sui_client_config::SuiEnv,
    types::base_types::SuiAddress,
    wallet_context::WalletContext,
};
use tokio::sync::Mutex;
use tracing::instrument;
use walrus_core::{BlobId, EpochCount};
use walrus_sui::{
    client::{get_system_package_id, BlobPersistence, SuiContractClient, SuiReadClient},
    test_utils::temp_dir_wallet,
};
use walrus_test_utils::WithTempDir;

use super::{
    daemon::{WalrusReadClient, WalrusWriteClient},
    dedup_metrics::ClientMetrics,
    dedup_refill::{CoinRefill, NetworkOrWallet, RefillHandles, Refiller},
    responses::BlobStoreResult,
    Client,
    ClientError,
    ClientResult,
    StoreWhen,
};
use crate::client::Config;

#[derive(Debug, thiserror::Error)]
pub enum ClientPoolError {
    /// There aren't enough available clients to complete the operation.
    #[error("there aren't enough available clients")]
    OutOfClients,
    /// An error generated by the inner client.
    #[error(transparent)]
    InnerClient(#[from] ClientError),
}

type ClientPoolResult<T> = Result<T, ClientPoolError>;

pub struct ClientMultiplexer {
    client_pool: WriteClientPool,
    read_client: Client<SuiReadClient>,
    _refill_handles: RefillHandles,
}

impl ClientMultiplexer {
    pub async fn new(
        n_clients: usize,
        contract_client: SuiContractClient,
        config: &Config,
        gas_budget: u64,
        refill_interval: Duration,
        prometheus_registry: &Registry,
    ) -> anyhow::Result<Self> {
        let sui_client = contract_client.sui_client().clone();
        let sui_read_client = contract_client.read_client.clone();
        let read_client = Client::new_read_client(config.clone(), sui_read_client).await?;

        let sui_env = contract_client
            .wallet()
            .await
            .config
            .get_active_env()?
            .clone();

        let system_pkg_id = get_system_package_id(&sui_client, config.system_object).await?;
        let refiller = Refiller::new(
            NetworkOrWallet::new_wallet(contract_client, gas_budget).expect("TODO: propagate"),
            system_pkg_id,
        );

        let client_pool =
            WriteClientPool::new(n_clients, config, sui_env, gas_budget, &refiller).await?;

        let metrics = Arc::new(ClientMetrics::new(prometheus_registry));
        let refill_handles = refiller.refill_gas_and_wal(
            client_pool.addresses(),
            refill_interval,
            metrics,
            sui_client,
        );

        Ok(Self {
            client_pool,
            read_client,
            _refill_handles: refill_handles,
        })
    }

    pub async fn submit_write(
        &self,
        blob: &[u8],
        epochs_ahead: EpochCount,
        store_when: StoreWhen,
        persistence: BlobPersistence,
    ) -> ClientResult<BlobStoreResult> {
        let (client_idx, client) = self.client_pool.next_client().await;
        tracing::debug!(%client_idx, "submitting write request to client in pool");

        let result = client
            .reserve_and_store_blob_retry_epoch(blob, epochs_ahead, store_when, persistence)
            .await?;

        Ok(result)
    }
}

impl WalrusReadClient for ClientMultiplexer {
    async fn read_blob(&self, blob_id: &BlobId) -> ClientResult<Vec<u8>> {
        WalrusReadClient::read_blob(&self.read_client, blob_id).await
    }

    fn set_metric_registry(&mut self, registry: &Registry) {
        self.read_client.set_metric_registry(registry);
    }
}

impl WalrusWriteClient for ClientMultiplexer {
    async fn write_blob(
        &self,
        blob: &[u8],
        epochs_ahead: EpochCount,
        store_when: StoreWhen,
        persistence: BlobPersistence,
    ) -> ClientResult<BlobStoreResult> {
        self.submit_write(blob, epochs_ahead, store_when, persistence)
            .await
    }
}

pub trait ClientPool<C> {
    fn next_client(&self) -> impl Future<Output = (usize, C)>;
    fn release_client(&self, idx: usize);
}

impl ClientPool<Arc<TempWriteClient>> for WriteClientPool {
    async fn next_client(&self) -> (usize, Arc<TempWriteClient>) {
        self.next_client().await
    }

    fn release_client(&self, _idx: usize) {
        // Do nothing, the client is released automatically.
    }
}

pub struct WriteClientPool {
    pool: Vec<Arc<TempWriteClient>>,
    cur_idx: Mutex<usize>,
}

impl WriteClientPool {
    pub async fn new<G: CoinRefill + 'static>(
        n_clients: usize,
        config: &Config,
        sui_env: SuiEnv,
        gas_budget: u64,
        refiller: &Refiller<G>,
    ) -> ClientPoolResult<Self> {
        let mut pool = Vec::with_capacity(n_clients);

        tracing::info!(%n_clients, "creating write client pool");
        for _ in 0..n_clients {
            let client = Arc::new(
                TempWriteClient::from_sui_env(config, sui_env.clone(), gas_budget, refiller)
                    .await
                    .expect("TODO: propagate"),
            );
            pool.push(client);
        }

        Ok(Self {
            pool,
            cur_idx: Mutex::new(0),
        })
    }

    /// Returns the addresses of the clients in the pool.
    pub fn addresses(&self) -> Vec<SuiAddress> {
        self.pool
            .iter()
            .map(|client| client.as_ref().address())
            .collect()
    }

    pub fn add_client(&mut self, client: Arc<TempWriteClient>) {
        self.pool.push(client);
    }

    pub async fn next_client(&self) -> (usize, Arc<TempWriteClient>) {
        let mut idx = self.cur_idx.lock().await;
        let cur_idx = *idx;

        let client = self
            .pool
            .get(cur_idx)
            .expect("the index is computed modulo the length and clients cannot be removed")
            .clone();

        let next = (cur_idx + 1) % self.pool.len();
        *idx = next;
        (cur_idx, client)
    }
}

/// A temporary write client for client multiplexing.
#[derive(Debug)]
pub(crate) struct TempWriteClient(WithTempDir<Client<SuiContractClient>>);

impl TempWriteClient {
    #[instrument(err, skip_all)]
    pub async fn from_sui_env<G: CoinRefill + 'static>(
        config: &Config,
        sui_env: SuiEnv,
        gas_budget: u64,
        refiller: &Refiller<G>,
    ) -> anyhow::Result<Self> {
        let client = new_client(config, sui_env, gas_budget, refiller).await?;
        Ok(Self(client))
    }

    /// Returns the active address of the client.
    pub fn address(&self) -> SuiAddress {
        self.0.as_ref().sui_client().address()
    }

    /// Stores the blob to Walrus, retrying if it fails because of epoch change.
    pub async fn reserve_and_store_blob_retry_epoch(
        &self,
        blob: &[u8],
        epochs_ahead: EpochCount,
        store_when: StoreWhen,
        persistence: BlobPersistence,
    ) -> ClientResult<BlobStoreResult> {
        Ok(self
            .0
            .as_ref()
            .reserve_and_store_blob_retry_epoch(blob, epochs_ahead, store_when, persistence)
            .await?)
    }
}

async fn new_client<G: CoinRefill + 'static>(
    config: &Config,
    sui_env: SuiEnv,
    gas_budget: u64,
    refiller: &Refiller<G>,
) -> anyhow::Result<WithTempDir<Client<SuiContractClient>>> {
    // Create the client with a separate wallet
    let wallet = wallet_for_testing_from_refill(sui_env, refiller).await?;
    let sui_read_client = config
        .new_read_client(wallet.as_ref().get_client().await?)
        .await?;
    let sui_contract_client = wallet.and_then(|wallet| {
        SuiContractClient::new_with_read_client(wallet, gas_budget, sui_read_client)
    })?;

    let client = sui_contract_client
        .and_then_async(|contract_client| {
            Client::new_contract_client(config.clone(), contract_client)
        })
        .await?;
    Ok(client)
}

pub async fn wallet_for_testing_from_refill<G: CoinRefill + 'static>(
    sui_env: SuiEnv,
    refiller: &Refiller<G>,
) -> anyhow::Result<WithTempDir<WalletContext>> {
    let mut wallet = temp_dir_wallet(sui_env)?;
    let address = wallet.as_mut().active_address()?;
    refiller.send_gas_request(address).await?;
    refiller.send_wal_request(address).await?;
    Ok(wallet)
}
