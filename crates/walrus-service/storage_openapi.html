<!DOCTYPE html>
<html>
  <head>
    <title>Redoc</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat:300,400,700|Roboto:300,400,700"
      rel="stylesheet"
    />

    <style>
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>

  <body>
    <div id="redoc-container"></div>
    <script src="https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"></script>
    <script>
      Redoc.init(
        {"openapi":"3.1.0","info":{"title":"walrus-service","description":"","contact":{"name":"Mysten Labs","email":"build@mystenlabs.com"},"license":{"name":"Apache-2.0","identifier":"Apache-2.0"},"version":"1.11.0"},"paths":{"/v1/blobs/{blob_id}/confirmation/deletable/{object_id}":{"get":{"tags":["Writing Blobs"],"summary":"Get storage confirmation for deletable blobs.","description":"Gets a signed storage confirmation from this storage node, indicating that all shards assigned\nto this storage node for the current epoch have stored their respective slivers.","operationId":"get_deletable_blob_confirmation","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}},{"name":"object_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/ObjectID"}}],"responses":{"200":{"description":"A signed confirmation of storage","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_StorageConfirmation"}}}},"400":{"description":"May be returned when (1)  The blob has not been registered or has already expired. (2)  The storage node cannot produce a certificate, as it does not have the slivers for all of its shards. Complete the uploading of the slivers and then try again.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}}},"/v1/blobs/{blob_id}/confirmation/permanent":{"get":{"tags":["Writing Blobs"],"summary":"Get storage confirmation for permanent blobs.","description":"Gets a signed storage confirmation from this storage node, indicating that all shards assigned\nto this storage node for the current epoch have stored their respective slivers.","operationId":"get_permanent_blob_confirmation","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}}],"responses":{"200":{"description":"A signed confirmation of storage","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_StorageConfirmation"}}}},"400":{"description":"May be returned when (1)  The blob has not been registered or has already expired. (2)  The storage node cannot produce a certificate, as it does not have the slivers for all of its shards. Complete the uploading of the slivers and then try again.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}}},"/v1/blobs/{blob_id}/inconsistencyProof/{sliver_type}":{"post":{"tags":["Recovery"],"summary":"Verify blob inconsistency.","description":"Accepts an inconsistency proof from other storage nodes, verifies it, and returns an attestation\nthat the specified blob is inconsistent.","operationId":"inconsistency_proof","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}},{"name":"sliver_type","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverType"}}],"requestBody":{"description":"BCS-encoded inconsistency proof","content":{"application/octet-stream":{"schema":{"type":"array","items":{"type":"integer","format":"int32","minimum":0}}}},"required":true},"responses":{"200":{"description":"Signed invalid blob-id attestation","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_SignedMessage_u8"}}}},"400":{"description":"May be returned when (1)  The metadata for the blob is required but missing. (2)  The provided inconsistency proof is not valid.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}}},"/v1/blobs/{blob_id}/metadata":{"get":{"tags":["Reading Blobs"],"summary":"Get blob metadata.","description":"Gets the metadata associated with a Walrus blob, as a BCS encoded byte stream.","operationId":"get_metadata","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}}],"responses":{"200":{"description":"BCS encoded blob metadata","content":{"application/octet-stream":{"schema":{"type":"array","items":{"type":"integer","format":"int32","minimum":0}}}}},"404":{"description":" The requested metadata could not be found at this storage node. It has either not been uploaded, does not exist, or has already been deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"451":{"description":" The metadata cannot be returned, as the associated blob has been blocked on this storage node.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}},"put":{"tags":["Writing Blobs"],"summary":"Store blob metadata.","description":"Stores the metadata associated with a registered Walrus blob at this storage node. This is a\npre-requisite for storing the encoded slivers of the blob. The ID of the blob must first be\nregistered on Sui, after which storing the metadata becomes possible.\n\nThis endpoint may return an error if the node has not yet received the registration event from\nthe chain.","operationId":"put_metadata","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}}],"requestBody":{"description":"BCS-encoded metadata octet-stream","content":{"application/octet-stream":{"schema":{"type":"array","items":{"type":"integer","format":"int32","minimum":0}}}},"required":true},"responses":{"200":{"description":"Metadata is already stored","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_String"}}}},"201":{"description":"Metadata successfully stored","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_String"}}}},"400":{"description":"May be returned when (1)  Storing the metadata cannot be completed because the blob has been marked as invalid by the system. (2)  The blob has not been registered or has already expired. (3)  The provided metadata is not valid for the blob.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}}},"/v1/blobs/{blob_id}/slivers/{sliver_pair_index}/{sliver_type}":{"get":{"tags":["Reading Blobs"],"summary":"Get blob slivers.","description":"Gets the primary or secondary sliver identified by the specified blob ID and index. The\nindex should represent a sliver that is assigned to be stored at one of the shards managed\nby this storage node during this epoch.","operationId":"get_sliver","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}},{"name":"sliver_pair_index","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverPairIndex"}},{"name":"sliver_type","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverType"}}],"responses":{"200":{"description":"BCS encoded primary or secondary sliver","content":{"application/octet-stream":{"schema":{"type":"array","items":{"type":"integer","format":"int32","minimum":0}}}}},"400":{"description":"May be returned when (1)  The index identifying the resource is out-of-range for the system. (2)  The shard associated with the operation is not assigned to this storage node.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"404":{"description":" The requested sliver could not be found at this storage node. It has either not been uploaded, does not exist, or has already been deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"451":{"description":" The sliver cannot be returned, as the associated blob has been blocked on this storage node.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}},"put":{"tags":["Writing Blobs"],"summary":"Store blob slivers.","description":"Stores a primary or secondary blob sliver at the storage node.","operationId":"put_sliver","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}},{"name":"sliver_pair_index","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverPairIndex"}},{"name":"sliver_type","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverType"}}],"requestBody":{"description":"BCS-encoded sliver octet-stream","content":{"application/octet-stream":{"schema":{"type":"array","items":{"type":"integer","format":"int32","minimum":0}}}},"required":true},"responses":{"200":{"description":"Sliver successfully stored","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_String"}}}},"400":{"description":"May be returned when (1)  The blob has not been registered or has already expired. (2)  The index identifying the resource is out-of-range for the system. (3)  The metadata for the blob is required but missing. (4)  The provided sliver failed verification against the previously uploaded metadata for that blob ID. (5)  The shard associated with the operation is not assigned to this storage node.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}}},"/v1/blobs/{blob_id}/slivers/{sliver_pair_index}/{sliver_type}/{target_pair_index}":{"get":{"tags":["Recovery"],"summary":"Get recovery symbols.","description":"Gets a symbol held by this storage node to aid in sliver recovery.\n\nThe `sliver_type` is the target type of the sliver that will be recovered.\nThe `sliver_pair_index` is the index of the sliver pair that we want to access.\nThe `target_pair_index` is the index of the target sliver.","operationId":"get_recovery_symbol","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}},{"name":"sliver_pair_index","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverPairIndex"}},{"name":"target_pair_index","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverPairIndex"}},{"name":"sliver_type","in":"path","required":true,"schema":{"$ref":"#/components/schemas/SliverType"}}],"responses":{"200":{"description":"BCS encoded symbol","content":{"application/octet-stream":{"schema":{"type":"array","items":{"type":"integer","format":"int32","minimum":0}}}}},"400":{"description":"May be returned when (1)  The index identifying the resource is out-of-range for the system. (2)  The shard associated with the operation is not assigned to this storage node.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"404":{"description":" The requested sliver could not be found at this storage node. It has either not been uploaded, does not exist, or has already been deleted.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"451":{"description":" The sliver cannot be returned, as the associated blob has been blocked on this storage node.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}},"deprecated":true}},"/v1/blobs/{blob_id}/status":{"get":{"tags":["Reading Blobs"],"summary":"Get the status of a blob.","description":"Gets the status of a blob as viewed by this storage node, such as whether it is registered,\ncertified, or invalid, and the event identifier on Sui that led to the change in status.","operationId":"get_blob_status","parameters":[{"name":"blob_id","in":"path","required":true,"schema":{"$ref":"#/components/schemas/BlobId"}}],"responses":{"200":{"description":"The status of the blob","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_BlobStatus"}}}},"500":{"description":"An internal server error has occurred. Please report this error.","content":{"application/json":{"schema":{"$ref":"#/components/schemas/Status"}}}}}}},"/v1/health":{"get":{"tags":["Status"],"summary":"Get storage health information.","description":"Gets the storage node's health information and basic running stats.","operationId":"health_info","parameters":[{"name":"detailed","in":"query","description":"When true, includes the status of each start in the health info.","required":false,"schema":{"type":"boolean"}}],"responses":{"200":{"description":"Server is running","content":{"application/json":{"schema":{"$ref":"#/components/schemas/ApiSuccess_ServiceHealthInfo"}}}}}}}},"components":{"schemas":{"ApiSuccess_BlobStatus":{"oneOf":[{"type":"object","required":["success"],"properties":{"success":{"type":"object","required":["code","data"],"properties":{"code":{"type":"integer","format":"int32","description":"INV: This is a valid status code.","minimum":0},"data":{"oneOf":[{"type":"string","description":"The blob does not exist (anymore) within Walrus.","enum":["nonexistent"]},{"type":"object","description":"The blob ID has been marked as invalid.","required":["invalid"],"properties":{"invalid":{"type":"object","description":"The blob ID has been marked as invalid.","required":["event"],"properties":{"event":{"$ref":"#/components/schemas/EventID"}}}}},{"type":"object","description":"The blob exists within Walrus in a permanent state.","required":["permanent"],"properties":{"permanent":{"type":"object","description":"The blob exists within Walrus in a permanent state.","required":["end_epoch","is_certified","status_event","deletable_counts"],"properties":{"deletable_counts":{"oneOf":[{"type":"object","description":"Contains counts of all and certified deletable `Blob` objects.","required":["count_deletable_total","count_deletable_certified"],"properties":{"count_deletable_certified":{"type":"integer","format":"int32","description":"Number of certified deletable `Blob` objects for the given blob ID.","minimum":0},"count_deletable_total":{"type":"integer","format":"int32","description":"Total number of active deletable `Blob` objects for the given blob ID.","minimum":0}}}],"description":"Counts of deletable `Blob` objects."},"end_epoch":{"type":"integer","format":"int64","description":"The latest epoch at which the blob expires (non-inclusive).","minimum":0},"initial_certified_epoch":{"oneOf":[{"type":"null"},{"$ref":"#/components/schemas/u32","description":"If the blob is certified, contains the epoch where it was initially certified."}]},"is_certified":{"type":"boolean","description":"Whether the blob is certified (true) or only registered (false)."},"status_event":{"$ref":"#/components/schemas/EventID"}}}}},{"type":"object","description":"The blob exists within Walrus; but there is no related permanent object, so it may be\ndeleted at any time.","required":["deletable"],"properties":{"deletable":{"type":"object","description":"The blob exists within Walrus; but there is no related permanent object, so it may be\ndeleted at any time.","required":["deletable_counts"],"properties":{"deletable_counts":{"oneOf":[{"type":"object","description":"Contains counts of all and certified deletable `Blob` objects.","required":["count_deletable_total","count_deletable_certified"],"properties":{"count_deletable_certified":{"type":"integer","format":"int32","description":"Number of certified deletable `Blob` objects for the given blob ID.","minimum":0},"count_deletable_total":{"type":"integer","format":"int32","description":"Total number of active deletable `Blob` objects for the given blob ID.","minimum":0}}}],"description":"Counts of deletable `Blob` objects."},"initial_certified_epoch":{"oneOf":[{"type":"null"},{"$ref":"#/components/schemas/u32","description":"If the blob is certified, contains the epoch where it was initially certified."}]}}}}}],"description":"Contains the certification status of a blob.\n\nIf the a permanent blob exists, it also contains its end epoch and the ID of the Sui event\nfrom which the latest status (registered or certified) resulted."}}}}}],"description":"Successful API response body as JSON.\n\nContains the HTTP code as well as a message or response object."},"ApiSuccess_ServiceHealthInfo":{"oneOf":[{"type":"object","required":["success"],"properties":{"success":{"type":"object","required":["code","data"],"properties":{"code":{"type":"integer","format":"int32","description":"INV: This is a valid status code.","minimum":0},"data":{"type":"object","description":"Represents information about the health of the storage node service.","required":["uptime","epoch","publicKey","nodeStatus","eventProgress","shardSummary"],"properties":{"epoch":{"type":"integer","format":"int64","description":"The epoch of the storage node.","minimum":0},"eventProgress":{"oneOf":[{"type":"object","description":"Represents the progress of the events.","required":["persisted","pending","highestFinishedEventIndex"],"properties":{"highestFinishedEventIndex":{"type":"integer","format":"int64","description":"The highest event index that has been finished.","minimum":0},"pending":{"type":"integer","format":"int64","description":"The number of events that are pending in memory.","minimum":0},"persisted":{"type":"integer","format":"int64","description":"The number of events that have been persisted.","minimum":0}}}],"description":"The event progress of the storage node."},"nodeStatus":{"type":"string","description":"The status of the storage node."},"publicKey":{"type":"array","items":{"type":"integer","format":"Base58","minimum":0},"description":"The public key of the storage node."},"shardDetail":{"oneOf":[{"type":"null"},{"$ref":"#/components/schemas/ShardStatusDetail","description":"The status of the shards for which the node is responsible."}]},"shardSummary":{"$ref":"#/components/schemas/ShardStatusSummary","description":"The overall status of the shards."},"uptime":{"type":"object","description":"The uptime of the service."}}}}}}}],"description":"Successful API response body as JSON.\n\nContains the HTTP code as well as a message or response object."},"ApiSuccess_SignedMessage_u8":{"oneOf":[{"type":"object","required":["success"],"properties":{"success":{"type":"object","required":["code","data"],"properties":{"code":{"type":"integer","format":"int32","description":"INV: This is a valid status code.","minimum":0},"data":{"type":"object","description":"A signed message from a storage node.","required":["serializedMessage","signature"],"properties":{"serializedMessage":{"type":"array","items":{"type":"integer","format":"byte","minimum":0},"description":"The BCS-encoded message.\n\nThis is serialized as a base64 string in human-readable encoding formats such as JSON."},"signature":{"type":"array","items":{"type":"integer","format":"byte","minimum":0},"description":"The signature over the BCS encoded message."}}}}}}}],"description":"Successful API response body as JSON.\n\nContains the HTTP code as well as a message or response object."},"ApiSuccess_StorageConfirmation":{"oneOf":[{"type":"object","required":["success"],"properties":{"success":{"type":"object","required":["code","data"],"properties":{"code":{"type":"integer","format":"int32","description":"INV: This is a valid status code.","minimum":0},"data":{"oneOf":[{"type":"object","description":"Confirmation based on the storage node's signature.","required":["signed"],"properties":{"signed":{"$ref":"#/components/schemas/SignedMessage_u8","description":"Confirmation based on the storage node's signature."}}}],"description":"Confirmation from a storage node that it has stored the sliver pairs for a given blob."}}}}}],"description":"Successful API response body as JSON.\n\nContains the HTTP code as well as a message or response object."},"ApiSuccess_String":{"oneOf":[{"type":"object","required":["success"],"properties":{"success":{"type":"object","required":["code","data"],"properties":{"code":{"type":"integer","format":"int32","description":"INV: This is a valid status code.","minimum":0},"data":{"type":"string"}}}}}],"description":"Successful API response body as JSON.\n\nContains the HTTP code as well as a message or response object."},"BlobStatus":{"oneOf":[{"type":"string","description":"The blob does not exist (anymore) within Walrus.","enum":["nonexistent"]},{"type":"object","description":"The blob ID has been marked as invalid.","required":["invalid"],"properties":{"invalid":{"type":"object","description":"The blob ID has been marked as invalid.","required":["event"],"properties":{"event":{"$ref":"#/components/schemas/EventID"}}}}},{"type":"object","description":"The blob exists within Walrus in a permanent state.","required":["permanent"],"properties":{"permanent":{"type":"object","description":"The blob exists within Walrus in a permanent state.","required":["end_epoch","is_certified","status_event","deletable_counts"],"properties":{"deletable_counts":{"oneOf":[{"type":"object","description":"Contains counts of all and certified deletable `Blob` objects.","required":["count_deletable_total","count_deletable_certified"],"properties":{"count_deletable_certified":{"type":"integer","format":"int32","description":"Number of certified deletable `Blob` objects for the given blob ID.","minimum":0},"count_deletable_total":{"type":"integer","format":"int32","description":"Total number of active deletable `Blob` objects for the given blob ID.","minimum":0}}}],"description":"Counts of deletable `Blob` objects."},"end_epoch":{"type":"integer","format":"int64","description":"The latest epoch at which the blob expires (non-inclusive).","minimum":0},"initial_certified_epoch":{"oneOf":[{"type":"null"},{"$ref":"#/components/schemas/u32","description":"If the blob is certified, contains the epoch where it was initially certified."}]},"is_certified":{"type":"boolean","description":"Whether the blob is certified (true) or only registered (false)."},"status_event":{"$ref":"#/components/schemas/EventID"}}}}},{"type":"object","description":"The blob exists within Walrus; but there is no related permanent object, so it may be\ndeleted at any time.","required":["deletable"],"properties":{"deletable":{"type":"object","description":"The blob exists within Walrus; but there is no related permanent object, so it may be\ndeleted at any time.","required":["deletable_counts"],"properties":{"deletable_counts":{"oneOf":[{"type":"object","description":"Contains counts of all and certified deletable `Blob` objects.","required":["count_deletable_total","count_deletable_certified"],"properties":{"count_deletable_certified":{"type":"integer","format":"int32","description":"Number of certified deletable `Blob` objects for the given blob ID.","minimum":0},"count_deletable_total":{"type":"integer","format":"int32","description":"Total number of active deletable `Blob` objects for the given blob ID.","minimum":0}}}],"description":"Counts of deletable `Blob` objects."},"initial_certified_epoch":{"oneOf":[{"type":"null"},{"$ref":"#/components/schemas/u32","description":"If the blob is certified, contains the epoch where it was initially certified."}]}}}}}],"description":"Contains the certification status of a blob.\n\nIf the a permanent blob exists, it also contains its end epoch and the ID of the Sui event\nfrom which the latest status (registered or certified) resulted."},"Epoch":{"type":"integer","format":"int32","description":"Walrus epoch.","minimum":0},"EventID":{"type":"object","description":"Schema for the [`sui_types::event::EventID`] type.","required":["txDigest","eventSeq"],"properties":{"eventSeq":{"type":"string"},"txDigest":{"type":"array","items":{"type":"integer","format":"byte","minimum":0}}},"examples":[{"txDigest":"EhtoQF9UpPyg5PsPUs69LdkcRrjQ3R4cTsHnwxZVTNrC","eventSeq":0}]},"ObjectID":{"type":"string","title":"Sui object ID","description":"Sui object ID as a hexadecimal string","examples":["0x56ae1c86e17db174ea002f8340e28880bc8a8587c56e8604a4fa6b1170b23a60"]},"ServiceHealthInfo":{"type":"object","description":"Represents information about the health of the storage node service.","required":["uptime","epoch","publicKey","nodeStatus","eventProgress","shardSummary"],"properties":{"epoch":{"type":"integer","format":"int64","description":"The epoch of the storage node.","minimum":0},"eventProgress":{"oneOf":[{"type":"object","description":"Represents the progress of the events.","required":["persisted","pending","highestFinishedEventIndex"],"properties":{"highestFinishedEventIndex":{"type":"integer","format":"int64","description":"The highest event index that has been finished.","minimum":0},"pending":{"type":"integer","format":"int64","description":"The number of events that are pending in memory.","minimum":0},"persisted":{"type":"integer","format":"int64","description":"The number of events that have been persisted.","minimum":0}}}],"description":"The event progress of the storage node."},"nodeStatus":{"type":"string","description":"The status of the storage node."},"publicKey":{"type":"array","items":{"type":"integer","format":"Base58","minimum":0},"description":"The public key of the storage node."},"shardDetail":{"oneOf":[{"type":"null"},{"$ref":"#/components/schemas/ShardStatusDetail","description":"The status of the shards for which the node is responsible."}]},"shardSummary":{"$ref":"#/components/schemas/ShardStatusSummary","description":"The overall status of the shards."},"uptime":{"type":"object","description":"The uptime of the service."}}},"ShardHealthInfo":{"type":"object","description":"A shard with its status.","required":["shard","status"],"properties":{"shard":{"type":"integer","format":"int32","description":"The identifier of the shard in the walrus system.","minimum":0},"status":{"$ref":"#/components/schemas/ShardStatus","description":"The status of the shard, None if unavailable."}}},"ShardStatus":{"type":"string","description":"The current state of a shard on the storage node.","enum":["unknown","ready","inTransfer","inRecovery","readOnly"]},"ShardStatusDetail":{"type":"object","description":"Detail statuses of individual shards.\n\nProvides the status of each shard for which the node is responsible. Additionally, will provide\nthe status of shards which the node is not responsible for in the current epoch, but\nnonetheless currently stores. These will not appear in the [`ShardStatusSummary`].","required":["owned","other"],"properties":{"other":{"type":"array","items":{"$ref":"#/components/schemas/ShardHealthInfo"},"description":"Statuses of other shards the node currently stores."},"owned":{"type":"array","items":{"$ref":"#/components/schemas/ShardHealthInfo"},"description":"Statuses of the shards for which the node is responsible in this epoch."}}},"ShardStatusSummary":{"type":"object","description":"Summary of the shard statuses.\n\nSummarises the number of nodes for which this node is responsible, as well as those that are\nbeing transferred to another storage node.","required":["owned","ownedShardStatus","readOnly"],"properties":{"owned":{"type":"integer","description":"The number of shards, for which this node is responsible.\n\nTheir statuses are summarized in `owned_shard_status`.","minimum":0},"ownedShardStatus":{"oneOf":[{"type":"object","description":"The status of the shards for which the node is responsible.","required":["unknown","ready","inTransfer","inRecovery"],"properties":{"inRecovery":{"type":"integer","description":"The number of owned shards that are being recovered.","minimum":0},"inTransfer":{"type":"integer","description":"The number of owned shards that are being transferred to the node.","minimum":0},"ready":{"type":"integer","description":"The number of owned shards that are up-to-date for the epoch.","minimum":0},"unknown":{"type":"integer","description":"The number of owned shards in an unknown state.","minimum":0}}}],"description":"The statuses of the shards for which this node is responsible."},"readOnly":{"type":"integer","description":"The number of shards, no longer owned by the node, that are read only,\ni.e., only serving reads from this node.","minimum":0}}},"SignedMessage_u8":{"type":"object","description":"A signed message from a storage node.","required":["serializedMessage","signature"],"properties":{"serializedMessage":{"type":"array","items":{"type":"integer","format":"byte","minimum":0},"description":"The BCS-encoded message.\n\nThis is serialized as a base64 string in human-readable encoding formats such as JSON."},"signature":{"type":"array","items":{"type":"integer","format":"byte","minimum":0},"description":"The signature over the BCS encoded message."}}},"SliverPairIndex":{"type":"integer","format":"int32","description":"Represents the index of a sliver pair.\n\nAs blobs are encoded into as many pairs of slivers as there are shards in the committee,\nthis value ranges be from 0 to the number of shards (exclusive).","minimum":0},"SliverType":{"type":"string","description":"A type indicating either a primary or secondary sliver.","enum":["primary","secondary"]},"Status":{"type":"object","description":"A message returned from a failed API call.\n\nContains both human-readable and machine-readable details of the error,\nto assist in resolving the error.","required":["error"],"properties":{"error":{"allOf":[{"oneOf":[{"type":"object","required":["status","code"],"properties":{"code":{"type":"integer","format":"int32","description":"HTTP status code associated with the error.","minimum":0},"status":{"type":"string","description":"General type of error, given as an UPPER_SNAKE_CASE string."}}}],"description":"The status code corresponding to the error."},{"type":"object","required":["message","details"],"properties":{"details":{"type":"array","items":{"type":"object"},"description":"Machine readable details of the error.\n\nAlways contains an [`ErrorInfo`], which provides a machine-readable\nrepresentation of the of the `message` field."},"message":{"type":"string","description":"A message describing the error in detail."}}}]}}},"StorageConfirmation":{"oneOf":[{"type":"object","description":"Confirmation based on the storage node's signature.","required":["signed"],"properties":{"signed":{"$ref":"#/components/schemas/SignedMessage_u8","description":"Confirmation based on the storage node's signature."}}}],"description":"Confirmation from a storage node that it has stored the sliver pairs for a given blob."},"u32":{"type":"integer","format":"int32","minimum":0}}}},
        {},
        document.getElementById("redoc-container")
      );
    </script>
  </body>
</html>
