"use strict";(globalThis.webpackChunkwalrus_docusaurus=globalThis.webpackChunkwalrus_docusaurus||[]).push([[5490],{3153(e,t,s){s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});let n=JSON.parse('{"id":"system-overview/operations","title":"Operations","description":"Developer guide to Walrus operations for blob management.","source":"@site/../content/system-overview/operations.mdx","sourceDirName":"system-overview","slug":"/system-overview/operations","permalink":"/walrus/pr-preview/pr-3011/docs/system-overview/operations","draft":false,"unlisted":false,"editUrl":"https://github.com/MystenLabs/walrus/tree/main/docs/../content/system-overview/operations.mdx","tags":[],"version":"current","frontMatter":{"title":"Operations","description":"Developer guide to Walrus operations for blob management.","keywords":["walrus","operations","store","read","certify","delete","blob id","encoding","availability","developer operations"]},"sidebar":"docsSidebar","previous":{"title":"RedStuff Encoding Algorithm","permalink":"/walrus/pr-preview/pr-3011/docs/system-overview/red-stuff"},"next":{"title":"Available Networks","permalink":"/walrus/pr-preview/pr-3011/docs/system-overview/available-networks"}}');var o=s(2615),i=s(5756);let r={title:"Operations",description:"Developer guide to Walrus operations for blob management.",keywords:["walrus","operations","store","read","certify","delete","blob id","encoding","availability","developer operations"]},a,l={},d=[{value:"Upload",id:"upload",level:2},{value:"Maximum blob size",id:"maximum-blob-size",level:4},{value:"Read",id:"read",level:2},{value:"Download",id:"download",level:2},{value:"Certify availability",id:"certify-availability",level:2},{value:"Delete",id:"delete",level:2},{value:"Use Sui object and blob ID utilities",id:"use-sui-object-and-blob-id-utilities",level:2},{value:"Extend a blob&#39;s storage duration",id:"extend-a-blobs-storage-duration",level:2},{value:"Manage blob attributes",id:"manage-blob-attributes",level:2},{value:"Inconsistency handling",id:"inconsistency-handling",level:2},{value:"Reading inconsistent blobs",id:"reading-inconsistent-blobs",level:4},{value:"Challenge mechanism for storage attestation",id:"challenge-mechanism-for-storage-attestation",level:2}];function c(e){let t={a:"a",admonition:"admonition",code:"code",h2:"h2",h4:"h4",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components},{Term:n}=t;return n||function(e,t){throw Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Term",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:[(0,o.jsx)(n,{lookup:"Blob",children:"Blobs"})," can be interacted with through familiar file system operations such as uploading, reading, downloading, and deleting."]}),"\n",(0,o.jsx)(t.h2,{id:"upload",children:"Upload"}),"\n",(0,o.jsx)(t.p,{children:"Use the following command to upload a file to Walrus"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"$ walrus store file.txt --epochs 2 --context testnet\n"})}),"\n",(0,o.jsx)(t.admonition,{type:"danger",children:(0,o.jsxs)(t.p,{children:["All ","blobs"," stored in Walrus are public and discoverable by all. Do not store secrets or private data without additional confidentiality measures, such as encrypting with ",(0,o.jsx)(t.a,{href:"/docs/data-security",children:"Seal"}),"."]})}),"\n",(0,o.jsxs)(t.p,{children:["When you run this command, the steps executed by the ",(0,o.jsx)(n,{lookup:"Client",children:"client"})," are:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"Acquire a storage resource of appropriate size and duration on-chain, either directly from the Walrus system object or a secondary market. Storage resources can be split, merged, and transferred."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Apply erasure coding to the ","blob",", then compute the ",(0,o.jsx)(n,{lookup:"Blob ID",children:"blob ID"})," from the encoded data. The ","blob ID"," is a ",(0,o.jsx)(t.code,{children:"u256"})," value typically encoded as a URL-safe base64 string. You can perform the remaining steps yourself or delegate them to a ",(0,o.jsx)(n,{lookup:"Publisher",children:"publisher"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Interact with Sui to update a storage resource and register the ","blob ID"," with the desired size and lifetime. This emits an event that ",(0,o.jsx)(n,{lookup:"Storage node",children:"storage nodes"})," receive; the upload continues after event confirmation. Metadata is the only ","blob"," element ever exposed to Sui or ",(0,o.jsx)(t.a,{href:"https://docs.sui.io/guides/operator/validator-index",children:"its validators"}),", as the content of ","blobs"," is always stored off-chain on Walrus ","storage nodes"," and caches. The ","storage nodes"," or caches do not need to overlap with any Sui infrastructure components (such as validators), and the ",(0,o.jsx)(t.a,{href:"/blog/04_testnet_update#epochs",children:"storage epochs"})," can have different lengths and timing than ",(0,o.jsx)(t.a,{href:"https://docs.sui.io/concepts/sui-architecture/epochs",children:"Sui epochs"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Send ",(0,o.jsx)(n,{lookup:"Blob metadata",children:"blob metadata"})," to all ","storage nodes",". Each ",(0,o.jsx)(n,{lookup:"Sliver",children:"sliver"})," is sent to the ","storage node"," managing its corresponding ",(0,o.jsx)(n,{lookup:"Shard",children:"shard"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Each ","storage node"," receives its ","sliver",", verifies it against the ","blob ID",", and checks that a valid ","blob"," resource authorizes the store. If correct, it signs a statement confirming it holds the ","sliver",". Collect these signatures and aggregate them into an availability certificate."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Submit the availability certificate to the chain. Successful on-chain verification emits an availability event (the ",(0,o.jsx)(n,{lookup:"Point of availability",children:"point of availability (PoA)"}),") and triggers all ","storage nodes"," to download any missing shards. After the ","PoA",", ","storage nodes"," sync and recover missing metadata and slivers without your involvement."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(n,{lookup:"Certificate of availability",children:"certificate of availability"})," is created from 2/3 of the returned ","shard"," signatures. The erasure code rate is below 1/3, meaning that ",(0,o.jsx)(n,{lookup:"Reconstruction",children:"reconstruction"})," is possible even if only 1/3 of shards return the ","sliver"," for a read. Because at most 1/3 of the ","storage nodes"," can fail, this ensures ","reconstruction"," if you request slivers from all ","storage nodes",". A ","publisher"," can mediate the full process by receiving a ","blob"," and driving the process to completion."]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Read completion:"})," After the ","PoA"," for a ","blob ID",", any correct ",(0,o.jsx)(n,{lookup:"User",children:"user"})," performing a read within the ",(0,o.jsx)(n,{lookup:"Availability period",children:"availability period"})," eventually terminates and receives a value (V). This value is either the ","blob"," contents (F) or ",(0,o.jsx)(t.code,{children:"None"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Read consistency:"})," After the ","PoA",", if 2 correct users perform reads and receive values (V) and (V') respectively, then (V = V'). All correct readers see the same value."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Correct storage guarantee:"})," A correct ","user"," with an appropriate storage resource can always perform a store operation for a ","blob"," (F) with a ","blob ID"," and advance the protocol until the ","PoA","."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsxs)(t.strong,{children:["Correct ","blob"," retrieval:"]})," A read after the ","PoA"," for a ","blob"," (F) stored by a correct ","user"," returns (F). Correctly stored ","blobs"," are always retrievable."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["These steps are also performed by a ","publisher"," that accepts and publishes ","blobs"," through HTTP."]}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"Write paths of Walrus",src:s(9624).A+"",width:"851",height:"891"})}),"\n",(0,o.jsxs)(t.h4,{id:"maximum-blob-size",children:["Maximum ","blob"," size"]}),"\n",(0,o.jsxs)(t.p,{children:["The maximum ","blob"," size can be queried through the ",(0,o.jsx)(t.a,{href:"/docs/walrus-client/storing-blobs#walrus-system-information",children:(0,o.jsx)(t.code,{children:"walrus info"})})," CLI command. The maximum ","blob"," size is currently 13.3\xa0GB. You can store larger ","blobs"," by splitting them into smaller chunks."]}),"\n",(0,o.jsxs)(t.p,{children:["Blobs"," are stored for the number of epochs specified at the time they are stored. Walrus ","storage nodes"," ensure the ","blob"," is available through the number of epochs specified. Mainnet uses an epoch duration of 2 weeks."]}),"\n",(0,o.jsx)(t.h2,{id:"read",children:"Read"}),"\n",(0,o.jsxs)(t.p,{children:["To read a ","blob"," after it has been stored on Walrus, use the ",(0,o.jsx)(t.code,{children:"walrus read"})," command and provide the ","blob ID",":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"$ walrus read <blob-id> --context testnet\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Reading a ","blob"," does not save it to a local storage location. See ",(0,o.jsx)(t.a,{href:"#download",children:"download"})," for more information."]}),"\n",(0,o.jsxs)(t.p,{children:["Read operations are performed by the ","client"," or the ",(0,o.jsx)(n,{lookup:"Aggregator",children:"aggregator"})," service that exposes an HTTP interface to read ","blobs",". Reads are resilient and succeed in recovering the ","blob"," if up to 1/3 of ","storage nodes"," are unavailable. In most cases, after synchronization is complete, ","blobs"," can be read even if 2/3 of ","storage nodes"," are down."]}),"\n",(0,o.jsxs)(t.p,{children:["Reading ","blobs"," from Walrus can occur directly or through aggregators and caches. The operations are identical whether performed by end users, aggregators, or caches experiencing ",(0,o.jsx)(n,{lookup:"Cache",children:"cache"})," misses. In practice, most reads occur through caches for frequently accessed ","blobs"," and do not require requests to ","storage nodes","."]}),"\n",(0,o.jsx)(t.p,{children:"The read flow uses the following steps:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The network uses the ","blob ID"," to obtain the metadata for the ","blob ID"," from any ","storage node"," and authenticate it using the ","blob ID","."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The system object on Sui is queried to determine the ","storage nodes"," that store that ","blob","'s metadata and slivers."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["A request is sent to the ","storage nodes"," for the shards corresponding to the ","blob ID",". The request waits for (f+1) responses. Sufficient requests are sent in parallel to ensure low latency for reads."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The returned slivers are authenticated with the ","blob ID",", the ","blob"," is reconstructed, and the contents are determined to be either valid or inconsistent."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Optionally, the result is cached and can be served without ","reconstruction"," until it is evicted from the ","cache",". Requests to the ","cache"," for the ","blob"," return the ","blob"," contents or an ",(0,o.jsx)(n,{lookup:"Inconsistency proof",children:"inconsistency proof"}),"."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"download",children:"Download"}),"\n",(0,o.jsxs)(t.p,{children:["To download a ","blob"," and save it on your local machine, run the following command:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"$ walrus read <blob-id> --out file.txt --context testnet\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Replace ",(0,o.jsx)(t.code,{children:"<blob-id>"})," with the ","blob","'s identifier that the ",(0,o.jsx)(t.code,{children:"walrus store"})," command returns in its output, and replace ",(0,o.jsx)(t.code,{children:"file.txt"})," with the name and file extension for storing the file locally."]}),"\n",(0,o.jsx)(t.h2,{id:"certify-availability",children:"Certify availability"}),"\n",(0,o.jsxs)(t.p,{children:["Once a ","blob"," is certified, Walrus ensures that sufficient slivers are always available on ","storage nodes"," to recover it within the specified epochs."]}),"\n",(0,o.jsxs)(t.p,{children:["You can verify ","blob"," availability in 3 ways:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsxs)(t.strong,{children:["Using the certified ","blob"," event:"]})," Use a Sui SDK read to authenticate the certified ","blob"," event emitted when the ","blob ID"," was certified on Sui. The ",(0,o.jsx)(t.code,{children:"walrus blob-status"})," command identifies the event ID to check."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsxs)(t.strong,{children:["Using the ","blob"," object:"]})," Use a Sui SDK read to authenticate the Sui ","blob"," object corresponding to the ","blob ID",", verify it is certified, before the ",(0,o.jsx)(n,{lookup:"Expiry",children:"expiry"})," epoch, and not deletable."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Using a smart contract:"})," A Sui smart contract can read the ","blob"," object on Sui to verify it is certified, before the ","expiry"," epoch, and not deletable."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The underlying protocol of the ",(0,o.jsx)(t.a,{href:"https://github.com/MystenLabs/sui/tree/main/crates/sui-light-client",children:"Sui light client"})," returns digitally signed evidence for emitted events or objects, and can be used by offline or non-interactive applications as a proof of availability for the ","blob ID"," for a certain number of epochs."]}),"\n",(0,o.jsx)(t.h2,{id:"delete",children:"Delete"}),"\n",(0,o.jsxs)(t.p,{children:["To delete a ","blob",", run the following command:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"$ walrus delete --blob-id <blob-id> --context testnet\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Replace ",(0,o.jsx)(t.code,{children:"<blob-id>"})," with the ","blob","'s identifier that the ",(0,o.jsx)(t.code,{children:"walrus store"})," command returns in its output."]}),"\n",(0,o.jsxs)(t.p,{children:["Stored ","blobs"," can be set as deletable by the ","user"," that creates them. This metadata is stored in the Sui ","blob"," object, and whether a ","blob"," is deletable is included in certified ","blob"," events. A ",(0,o.jsx)(n,{lookup:"Deletable blob",children:"deletable blob"})," can be deleted by the owner of the ","blob"," object to reclaim and reuse the storage resource associated with it."]}),"\n",(0,o.jsxs)(t.p,{children:["If no other copies of the ","blob"," exist on Walrus, deleting a ","blob"," eventually makes it unrecoverable using read commands. However, if other copies of the ","blob"," exist on Walrus, a delete command reclaims storage space for the ","user"," that invoked it but does not make the ","blob"," unavailable until all other copies have been deleted or expire."]}),"\n",(0,o.jsxs)(t.h2,{id:"use-sui-object-and-blob-id-utilities",children:["Use Sui object and ","blob ID"," utilities"]}),"\n",(0,o.jsxs)(t.p,{children:["The command ",(0,o.jsx)(t.code,{children:"walrus blob-id <FILE>"})," derives the ","blob ID"," of any file. The ","blob ID"," is a commitment to the file, and any ","blob"," with the same ID decodes to the same content. The ","blob ID"," is a 256-bit number and represented on some Sui explorers as a large decimal number. The command ",(0,o.jsx)(t.code,{children:"walrus convert-blob-id <BLOB_ID_DECIMAL>"})," converts it to a base64 URL for use by the command line tools and other APIs."]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"walrus list-blobs"})," command lists all non-expired Sui objects that the current account owns, including their ","blob ID",", object ID, and metadata about expiration and deletable status. The ",(0,o.jsx)(t.code,{children:"--include-expired"})," option also lists expired Sui objects."]}),"\n",(0,o.jsxs)(t.p,{children:["The Sui storage cost associated with Sui objects can be reclaimed by burning the Sui object. This does not cause the Walrus ","blob"," to be deleted, but means that operations such as extending its lifetime, deleting it, or modifying attributes are no longer available. The ",(0,o.jsx)(t.code,{children:"walrus burn-blobs --object-ids <SUI_OBJ_IDS>"})," command burns a specific list of Sui object IDs. The ",(0,o.jsx)(t.code,{children:"--all"})," flag burns the Sui objects for all ","blobs"," under the ","user"," account, and ",(0,o.jsx)(t.code,{children:"--all-expired"})," burns all expired ","blobs"," under the ","user"," account."]}),"\n",(0,o.jsxs)(t.h2,{id:"extend-a-blobs-storage-duration",children:["Extend a ","blob","'s storage duration"]}),"\n",(0,o.jsxs)(t.p,{children:["Because no ","blob"," content is involved, refresh operations are conducted entirely through the Sui protocol. To extend a ","blob","'s storage duration, you must reference the Sui object ID and indicate how many epochs you want to extend the ","blob","'s storage for."]}),"\n",(0,o.jsxs)(t.p,{children:["Run the following command to extend a ","blob","'s storage duration by 3 epochs. You must use the Sui object ID, not the ","blob ID",":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:"$ walrus extend --blob-obj-id <blob-object-id> --epochs-extended 3 --context testnet\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Replace ",(0,o.jsx)(t.code,{children:"<blob-object-id>"})," with the ","blob","'s Sui object ID that the ",(0,o.jsx)(t.code,{children:"walrus store"})," command returns in its output. Upon success, ","storage nodes"," receive an emitted event to extend the storage duration for each ","sliver","."]}),"\n",(0,o.jsxs)(t.h2,{id:"manage-blob-attributes",children:["Manage ","blob"," attributes"]}),"\n",(0,o.jsxs)(t.p,{children:["Walrus allows a set of key-value attribute pairs to be associated with a Sui object. While the keys and their values can be arbitrary strings to accommodate any needs, specific keys are converted to HTTP headers when serving ","blobs"," through aggregators. Each ","aggregator"," can decide which headers it allows through the ",(0,o.jsx)(t.code,{children:"--allowed-headers"})," CLI option. You can view the defaults through ",(0,o.jsx)(t.code,{children:"walrus aggregator --help"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["The following command sets attributes ",(0,o.jsx)(t.code,{children:"key1"})," and ",(0,o.jsx)(t.code,{children:"key2"})," to values ",(0,o.jsx)(t.code,{children:"value1"})," and ",(0,o.jsx)(t.code,{children:"value2"}),", respectively. The command ",(0,o.jsx)(t.code,{children:"walrus get-blob-attribute <blob-object-id>"})," returns all attributes associated with a ","blob ID","."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:'$ walrus set-blob-attribute <blob-object-id> --attr "key1" "value1" --attr "key2" "value2"\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The following command deletes the attributes with keys listed, separated by commas or spaces. All attributes of a Sui object can be deleted by the command ",(0,o.jsx)(t.code,{children:"walrus remove-blob-attribute <blob-object-id>"}),"."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-sh",children:'$ walrus remove-blob-attribute-fields <blob-object-id> --keys "key1,key2"\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Attributes are associated with Sui object IDs rather than the ","blobs"," themselves on Walrus. This means that gas for storage is reclaimed by deleting attributes and that the same ","blob"," contents can have different attributes for different Sui objects with the same ","blob ID","."]}),"\n",(0,o.jsx)(t.h2,{id:"inconsistency-handling",children:"Inconsistency handling"}),"\n",(0,o.jsxs)(t.p,{children:["After the ","PoA",", a correct ","storage node"," attempting to reconstruct a ","sliver"," might fail if ","blob"," encoding was incorrect. In this case, the node can extract an ","inconsistency proof"," for the ","blob ID",". It then uses the proof to create an ",(0,o.jsx)(n,{lookup:"Inconsistency certificate",children:"inconsistency certificate"})," and uploads it on-chain."]}),"\n",(0,o.jsx)(t.p,{children:"Inconsistency handling uses the following process:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["A ","storage node"," fails to reconstruct a ","sliver"," and computes an ","inconsistency proof","."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The ","storage node"," sends the ","blob ID"," and ","inconsistency proof"," to all ","storage nodes"," of the Walrus epoch. The ","storage nodes"," verify the proof and sign it."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The ","storage node"," that found the inconsistency aggregates the signatures into an ","inconsistency certificate"," and sends it to the ",(0,o.jsx)(t.a,{href:"https://docs.sui.io/guides/developer/sui-101/move-package-management",children:"Sui smart contract"}),", which verifies it and emits an inconsistent resource event."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["Upon receiving an inconsistent resource event, correct ","storage nodes"," delete ","sliver"," data for the ","blob ID"," and record in the metadata to return ",(0,o.jsx)(t.code,{children:"None"})," for the ","blob"," during the ","availability period",". No ",(0,o.jsx)(n,{lookup:"Storage attestation",children:"storage attestation"})," challenges are issued for this ","blob ID","."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.h4,{id:"reading-inconsistent-blobs",children:["Reading inconsistent ","blobs"]}),"\n",(0,o.jsxs)(t.p,{children:["A ","blob ID"," marked as inconsistent always resolves to ",(0,o.jsx)(t.code,{children:"None"})," upon reading. This occurs because the read process re-encodes the received ","blob"," to verify that the ","blob ID"," was derived from consistent encoding."]}),"\n",(0,o.jsxs)(t.p,{children:["An ","inconsistency proof"," reveals only a true fact to ","storage nodes"," (which do not otherwise run decoding) and does not change read output in any case."]}),"\n",(0,o.jsx)(t.p,{children:"However, partial reads that use the systematic nature of the encoding might successfully return partial data for inconsistently encoded files. If consistency and availability of reads is important, perform full reads rather than partial reads."}),"\n",(0,o.jsxs)(t.h2,{id:"challenge-mechanism-for-storage-attestation",children:["Challenge mechanism for ","storage attestation"]}),"\n",(0,o.jsxs)(t.p,{children:["During an epoch, a correct ","storage node"," challenges all shards to provide symbols for ","blob"," slivers past ","PoA",":"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The list of available ","blobs"," for the epoch is determined by the sequence of Sui events up to the past epoch. Inconsistent ","blobs"," are not challenged, and a record proving this status can be returned instead."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["A challenge sequence is determined by providing a seed to the challenged ","shard",". The sequence is then computed based on the seed and the content of each challenged ","blob ID",". This creates a sequential read dependency."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:["The response to the challenge provides the sequence of ","shard"," contents for the ","blob"," IDs in a timely manner."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"The challenger node uses thresholds to determine whether the challenge was passed and reports the result on-chain."}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsx)(t.p,{children:"The challenge and response communication is authenticated."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Challenges provide reassurance that the ","storage node"," can actually recover ","shard"," data in a probabilistic manner, preventing ","storage nodes"," from receiving payment without any evidence they can retrieve ","shard"," data. The sequential nature of the challenge and a reasonable timeout also ensure that the process is timely."]})]})}function h(e={}){let{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},5756(e,t,s){s.d(t,{R:()=>r,x:()=>a});var n=s(9471);let o={},i=n.createContext(o);function r(e){let t=n.useContext(i);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),n.createElement(i.Provider,{value:t},e.children)}},9624(e,t,s){s.d(t,{A:()=>n});let n=s.p+"assets/images/WriteFlow-a5c02d29e5afa38d8ef342e961f7404c.png"}}]);